# coding=utf-8
# --------------------------------------------------------------------
# Copyright (C) 1991 - 2020 - EDF R&D - www.code-aster.org
# This file is part of code_aster.
#
# code_aster is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# code_aster is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with code_aster.  If not, see <http://www.gnu.org/licenses/>.
# --------------------------------------------------------------------


# CAS_TEST__: TRACTION BIAXIAL
# ----------------------------------------------------------------------
# GEOMETRIE           : BARREAU
# MODELISATION        : 3D_GRAD_VARI
# MAILLAGE            : MED (ISSU DE SALOME)
# CL ET CHARGEMENT    : TRACTION BIAXIAL
# LOI D'ENDOMMAGEMENT : GTN NON LOCAL A 3 CHAMPS
# ----------------------------------------------------------------------
# i = [|0,20|], j = [|0,9|]
# GROUPES DE NOEUDS: F_Couche_i, F_Element_j, Fixe, V_Bar3D
# GROUPES DE MAILLES: V_Element_j, V_Bar3D
# ----------------------------------------------------------------------

DEBUT(CODE=_F(NIV_PUB_WEB='INTERNET'),DEBUG=_F(SDVERI='OUI'))


import math
import numpy as np
# -------------------------------------------------------------------------
# PARAMETRES
# -------------------------------------------------------------------------
# NOMBRE DU PAS DE CALCUL
nb_pas = 1000

# NOMBRE DU PAS D'ARCHIVAGE
nb_arch = 100

# INSTANT DE FIN <= DERNIER INSTANT DE CALCUL
inst_fin   = 800.0 

# DERNIER INSTANT
inst_total = 1000.0

# NOMBRE DE COUCHES
nbc = 10

# CAS AXIS-LIKE
alpha = 1
beta = 1.22

# LONGEUR DE CHAQUE BRIQUE
lx = 1.0
ly = 1.0


# LISTE
ACIER = nbc*[None]

# -------------------------------------------------------------------------
# OBJET ASTER
# -------------------------------------------------------------------------
# LECTURE DU MAILLAGE
MAIL=LIRE_MAILLAGE(FORMAT='MED', UNITE=20)

# AFFECTATION DU MODELE
MODE=AFFE_MODELE(MAILLAGE = MAIL,
           AFFE     = _F(TOUT         = 'OUI',
                   PHENOMENE    = 'MECANIQUE',
                          MODELISATION = '3D_GRAD_VARI',
                               ),
                  )

# MODELISATION DU MATERIAU 20 MnMoNi 5-5  (MAQUETTE)



f_0 = 2e-4
for i in range(nbc):
    f0 = f_0 + i*f_0
    ACIER[i] = DEFI_MATERIAU(
        ELAS       = _F(E=190000, NU=0.3),
        ECRO_NL    = _F(
            R0 = 488.361123569,
            RH = 0,
            R1 = 57.1333673502,
            GAMMA_1 = 8613.0,
            R2 = 238.731127339,
            GAMMA_2 = 10.386585592,
            ),
        GTN = _F(
            Q1 = 1.5,
            Q2 = 1.07,
            PORO_INIT = f0,
            COAL_PORO = 0.05,
            COAL_ACCE = 3,
            ),
        NORTON  = _F(
            K=150.0, 
            N=14,
            ),
        NON_LOCAL = _F(
            C_GRAD_VARI = 1,
            PENA_LAGR   =5000,
            ),
        )


#-----------------------------------------------------------
# AFFECTATION DES MATERIAUX
#-----------------------------------------------------------

affe_mater = []
for i in range (nbc):
  mon_dico = {}
  mon_dico['GROUP_MA'] = ['V_Element_'+str(i)]
  mon_dico['MATER'] = [ACIER[i]]
  affe_mater.append(mon_dico)


MATE = AFFE_MATERIAU (MAILLAGE = MAIL, AFFE = affe_mater)


#-----------------------------------------------------------
# CONDITIONS AUX LIMITES ET CHARGEMENT
#-------------------------------------------------------------
#Liste_Couche = ['F_Couche_' + str(i) for i in range(0,2*nbc+1)]
Liaison_uni = []
for i in range (2*nbc+1):
  mon_dico = {}
  mon_dico['GROUP_NO'] = ['F_Couche_'+str(i)]
  mon_dico['DDL'] = ['DZ']
  Liaison_uni.append(mon_dico)


CL = AFFE_CHAR_MECA(MODELE    = MODE,
                    LIAISON_UNIF = Liaison_uni,)

ENCAST = AFFE_CHAR_CINE(MODELE    = MODE,
                    MECA_IMPO = _F(GROUP_NO = 'Fixe',  DZ = 0), # eviter le mouvement rigid
                     )

DEFX = DEFI_FONCTION(NOM_PARA = 'X',
                     VALE = (0,0,lx,beta),)

DEFY = DEFI_FONCTION(NOM_PARA = 'Y',
                     VALE = (0,0,ly,beta*alpha),)

CHARGE = AFFE_CHAR_CINE_F(MODELE    = MODE,
                          MECA_IMPO = _F(GROUP_NO = 'V_Bar3D',  DX = DEFX, DY = DEFY),)


# LISTE DES INSTANTS DE CALCUL
REEL_CAL = DEFI_LIST_REEL(DEBUT      = 0,
                          INTERVALLE = _F(JUSQU_A=inst_total, NOMBRE=nb_pas),)

INST_CAL = DEFI_LIST_INST(DEFI_LIST = _F(LIST_INST=REEL_CAL))

REEL_ARC = DEFI_LIST_REEL(DEBUT      = 0,
                          INTERVALLE = _F(JUSQU_A=inst_total, NOMBRE=nb_arch),)

FONC = DEFI_FONCTION(NOM_PARA = 'INST',
                     VALE     = (0.0, 0.0 ,inst_total, 1.0),
                     PROL_DROITE = 'LINEAIRE',)


# CALCUL NON LINEAIRE

RESU = STAT_NON_LINE (
    MODELE       = MODE,
    CHAM_MATER   = MATE ,
    EXCIT        = (_F(CHARGE = CL),
                    _F(CHARGE = ENCAST),
                    _F(CHARGE = CHARGE, FONC_MULT=FONC),
                    ),
    COMPORTEMENT = _F(TOUT = 'OUI', RELATION='VISC_GTN', DEFORMATION='GDEF_LOG'),
    INCREMENT    = _F(LIST_INST = INST_CAL, INST_FIN=inst_fin),
    CONVERGENCE  = _F(ITER_GLOB_MAXI= 20, RESI_GLOB_MAXI=1.E-3),
    NEWTON       = _F(MATRICE='TANGENTE',REAC_ITER=1),
    SOLVEUR      = _F(METHODE='MUMPS', PCENT_PIVOT=40, MATR_DISTRIBUEE='OUI',POSTTRAITEMENTS='MINI'),
    ARCHIVAGE    = _F(LIST_INST=REEL_ARC),
    )


# COORDONNEES DES POINTS DE GAUSS

COOR = CALC_CHAM_ELEM(MODELE = MODE,
                OPTION = 'COOR_ELGA',)

COORX = COOR.EXTR_COMP('X',['V_Bar3D']).valeurs
COORY = COOR.EXTR_COMP('Y',['V_Bar3D']).valeurs
COORZ = COOR.EXTR_COMP('Z',['V_Bar3D']).valeurs

    # PREMIER POINT A TESTER  PL : PG LE PLUS LOIN DE L'ORIGINE j
    # DEUXIEME POINT A TESTER PP : PG LE PLUS PROCHE DE L'ORIGINE k
    
npl = 0
npp = 0    
for i in range (len(COORX)):
    if(COORX[i]>0.5 and COORY[i]>0.5 and COORZ[i]>9.5):
        ipl = i
        npl += 1
    if(COORX[i]<0.5 and COORY[i]<0.5 and COORZ[i]<0.5):
        ipp = i
        npp += 1
        
assert npl == 1
assert npp == 1


SIGMA = CREA_CHAMP(TYPE_CHAM = 'ELGA_SIEF_R',
                 OPERATION = 'EXTR',
                   RESULTAT  = RESU,
                   NOM_CHAM  = 'SIEF_ELGA',
                   INST      = inst_fin,
                   )


VI = CREA_CHAMP(TYPE_CHAM = 'ELGA_VARI_R',
               OPERATION = 'EXTR',
                 RESULTAT  = RESU,
                 NOM_CHAM  = 'VARI_ELGA',
                 INST      = inst_fin,
                 )


# Contrainte SIXX

SIXX    = SIGMA.EXTR_COMP('SIXX',['V_Bar3D']).valeurs
SIXX_PL = CREA_TABLE(LISTE = (_F(PARA='SIXX',LISTE_R = SIXX[ipl])))
SIXX_PP = CREA_TABLE(LISTE = (_F(PARA='SIXX',LISTE_R = SIXX[ipp])))


TEST_TABLE(TABLE = SIXX_PL,
       NOM_PARA = 'SIXX',
           TYPE_TEST = 'MAX',
           VALE_CALC = 457.2847179852035,
           TOLE_MACHINE = 2.e-5,
           #REFERENCE= 'SOURCE_EXTERNE',
           #VALE_REFE= 4.099964e+02,
       #PRECISION = 0.01,
           )

TEST_TABLE(TABLE = SIXX_PP,
       NOM_PARA = 'SIXX',
           TYPE_TEST = 'MAX',
           VALE_CALC = 848.6540545143135,
           #TOLE_MACHINE = 1.e-4,
           #REFERENCE= 'SOURCE_EXTERNE',
           #VALE_REFE=7.586364e+02,
       #PRECISION = 0.01,
           )


#   VARIABLE D'ECROUISSAGE

PLAS    = VI.EXTR_COMP('V1',['V_Bar3D']).valeurs
PLAS_PL = CREA_TABLE(LISTE = (_F(PARA='V1',LISTE_R = PLAS[ipl])))
PLAS_PP = CREA_TABLE(LISTE = (_F(PARA='V1',LISTE_R = PLAS[ipp])))

TEST_TABLE(TABLE = PLAS_PL,
       NOM_PARA = 'V1',
           TYPE_TEST = 'MAX',
           VALE_CALC = 1.2817944954466234,
           REFERENCE= 'SOURCE_EXTERNE',
           VALE_REFE= 1.280017e+00,
       PRECISION = 0.01,
           )

TEST_TABLE(TABLE = PLAS_PP,
       NOM_PARA = 'V1',
           TYPE_TEST = 'MAX',
           VALE_CALC = 1.3545931184283075,
           REFERENCE= 'SOURCE_EXTERNE',
           VALE_REFE= 1.350605e+00,
       PRECISION = 0.01,
           )


#  POROSITE

PORO    = VI.EXTR_COMP('V2',['V_Bar3D']).valeurs
PORO_PL = CREA_TABLE(LISTE = (_F(PARA='V2',LISTE_R = PORO[ipl])))
PORO_PP = CREA_TABLE(LISTE = (_F(PARA='V2',LISTE_R = PORO[ipp])))

TEST_TABLE(TABLE = PORO_PL,
       NOM_PARA = 'V2',
           TYPE_TEST = 'MAX',
           VALE_CALC = 0.11727045362262208,
           REFERENCE= 'SOURCE_EXTERNE',
           VALE_REFE= 1.174330e-01,
       PRECISION = 0.01,
           )
           
TEST_TABLE(TABLE = PORO_PP,
       NOM_PARA = 'V2',
           TYPE_TEST = 'MAX',
           VALE_CALC = 0.012538556894467786,
           REFERENCE= 'SOURCE_EXTERNE',
           VALE_REFE= 1.256342e-02,
       PRECISION = 0.01,
           )
FIN()
